<div id="homepage">
  <div id="spinner" class="text-center" class="hide" v-class="hide: map">
    <i class="fa fa-spinner fa-spin fa-4x"></i>
  </div>
  <div id="map" class="map"></div>
</div>

<div id="marker-popup-template" class="hide" v-class="hide: !marker">
  <blockquote>
    <p>{{{json.text | autoLink}}}</p>
    <footer>@<a href="http://twitter.com/{{json.user.screen_name}}" target="_blank">{{json.user.screen_name}}</a> at <span>{{timestamp | time}}</span></footer>
  </blockquote>
</div>

<style>
#homepage, #map { height: 100%; }
#map { min-height: 500px; }
#spinner { padding: 100px; }
</style>

<script>
(function (root) {
  document.addEventListener('diseasetrackReady', function () {
    require(['jquery', 'vue', 'sails.io', 'leaflet', 'moment', 'twitter-text', 'binarysearch', 'leaflet.markercluster', 'leaflet.heat', 'leaflet.geosearch.provider.openstreetmap'], function (jQuery, Vue, io, L, moment, twitter, bs) {
      var $ = jQuery;
      Vue.config.async = false;
      Vue.filter('time', function (date) { return moment(date).format("h:mma"); })
      Vue.filter('autoLink', function (text) { return twitter.autoLink(text || '', {target: '_blank'}); });
      // Vue.component('marker-popup', {template: '#marker-popup-template'});
      var oneDay = moment.duration(1, 'day');
      var popupView = new Vue({el: '#marker-popup-template'});
      return root.homepageView = new Vue({
        el: '#homepage',
        data: {
          tweets: [],

          map: null,
          markerCluster: L.markerClusterGroup(),
          heatLayer: L.heatLayer([]),
        },
        ready: function () { this.subscribeToTweets(); },
        methods: {
          initMap: function () {
            var self = this;
            self.map = L.map('map', {
              center: [0, 0],
              zoom: 1,
              layers: [
                L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
                  attribution: '&copy; <a href="http://osm.org/copyright" target="_blank">OpenStreetMap</a>'
                }),
                self.heatLayer,
              ]
            });
            new L.Control.GeoSearch({
              provider: new L.GeoSearch.Provider.OpenStreetMap(),
              showMarker: false,
              zoomLevel: 5
            })
              .addTo(self.map);
            self.map.addLayer(self.markerCluster);
            return self.map;
          },
          subscribeToTweets: function () {
            var self = this;
            io.socket.get('/tweet', {
              retweeted: false,
              geo_status: 'resolved',
              timestamp: {'>': moment().subtract(oneDay).toDate()},
              sort: 'timestamp DESC'
            }, function (tweets) {
              self.initMap();
              self.addTweets(tweets);
            });
            io.socket.on('tweet', function (data) { self.addTweets([data.data]); });
          },
          addTweets: function (tweets) {
            console.log('addTweets', tweets.length);
            var self = this;
            var heatMarkers = [];
            var markers = $.map(tweets, function (tweet) {
              if (!tweet.geojson) return;
              popupView.$data = tweet;
              var popupHTML = popupView.$el.innerHTML;
              tweet.marker = L.marker(tweet.geojson.coordinates, {title: $('<div>').html(popupHTML).text()})
                .bindPopup(popupHTML);
              tweet.heatMarker = $.map(tweet.geojson.coordinates, Number)
                .concat([+moment(tweet.timestamp).subtract(oneDay) / +oneDay]);
              heatMarkers.push(tweet.heatMarker);
              return tweet.marker;
            });
            self.markerCluster.addLayers(markers);
            self.tweets = tweets.concat(self.tweets);
            var i = bs(self.tweets, {timestamp: moment().subtract(oneDay).toDate()}, function (tweet) {
              return (tweet || {}).timestamp;
            });
            if (i < 0) i = -i - 1;
            var removedTweets = self.tweets.splice(i, Infinity);
            self.markerCluster.removeLayers($.map(removedTweets, function (tweet) {
              return tweet.marker;
            }));
            self.heatLayer.setLatLngs(heatMarkers
              .concat(self.heatLayer._latlngs)
              .slice(0, self.tweets.length));
          }
        }
      });
    });
  });
}(this));
</script>
