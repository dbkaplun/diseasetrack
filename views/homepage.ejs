<div id="homepage">
  <div id="spinner" class="text-center hide" v-class="hide: map">
    <i class="fa fa-spinner fa-spin fa-4x"></i>
  </div>
  <div id="map" class="map"></div>
</div>

<div id="marker-popup-template" class="hide" v-class="hide: !marker">
  <blockquote>
    <p>{{{json.text | autoLink}}}</p>
    <footer>@<a href="http://twitter.com/{{json.user.screen_name}}" target="_blank">{{json.user.screen_name}}</a> at <span>{{timestamp | time}}</span></footer>
  </blockquote>
</div>

<a class="fork-me" href="https://github.com/secrettriangle/diseasetrack"><img src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>

<noscript>
  <h1>Sorry!</h1>
  <p>You need JavaScript enabled to view this page.</p>
</noscript>

<style>
#homepage, #map { height: 100%; }
#map { min-height: 500px; }
#spinner { padding: 100px; }
</style>

<script>
(function (root) {
  document.addEventListener('diseasetrackReady', function () {
    require(['jquery', 'vue', 'sails.io', 'leaflet', 'moment', 'twitter-text', 'binarysearch', 'mergesort', 'leaflet.markercluster', 'leaflet.heat', 'leaflet.geosearch.provider.openstreetmap'], function (jQuery, Vue, io, L, moment, twitter, bs, ms) {
      var keyCmp = function (key) { return function (a, b) { return key(a) - key(b); }; };
      var tweetKey = function (tweet) { return (tweet || {}).timestamp; };
      var tweetCmp = keyCmp(function (tweet) { return -tweetKey(tweet); });
      var insertionIndex = function (i) { return i < 0 ? -i - 1 : i; };

      var $ = jQuery;

      Vue.config.async = false;
      Vue.filter('time', function (date) { return moment(date).format("h:mma"); })
      Vue.filter('autoLink', function (text) { return twitter.autoLink(text || '', {target: '_blank'}); });
      // Vue.component('marker-popup', {template: '#marker-popup-template'});
      var popupView = new Vue({el: '#marker-popup-template'});
      return root.homepageView = new Vue({
        el: '#homepage',
        data: {
          tweets: [],

          map: null,
          markerCluster: L.markerClusterGroup(),
          heatLayer: L.heatLayer([]),

          TWEET_PRUNE_AGE: moment.duration(1, 'day'),
          TWEET_CHUNK_SIZE: 50,
          FETCH_TWEETS_INTERVAL: moment.duration(15, 'seconds')
        },
        ready: function () { this.subscribeToTweets(); },
        methods: {
          initMap: function () {
            var self = this;
            self.map = L.map('map', {
              center: [0, 0],
              zoom: 1,
              layers: [
                L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
                  attribution: '&copy; <a href="http://osm.org/copyright" target="_blank">OpenStreetMap</a>'
                }),
                self.heatLayer,
              ]
            });
            new L.Control.GeoSearch({
              provider: new L.GeoSearch.Provider.OpenStreetMap(),
              showMarker: false,
              zoomLevel: 5
            })
              .addTo(self.map);
            self.map.addLayer(self.markerCluster);
            return self.map;
          },
          subscribeToTweets: function () {
            var self = this;
            self.fetchTweets();
            io.socket.on('tweet', function (data) { self.addTweets([data.data]); });
            // self.fetchTweetsInterval = setInterval(function () {
            //   self.fetchTweets();
            // }, self.FETCH_TWEETS_INTERVAL);
          },
          fetchTweets: function () {
            var self = this;
            var recentTweet = self.tweets[0];
            self.getTweetsChunked(function (tweets) {
              if (!self.map) self.initMap();
              if (recentTweet) {
                var i = insertionIndex(bs(tweets, recentTweet, tweetKey));
                if (i < tweets.length) {
                  self.addTweets(tweets.slice(0, i));
                  return false;
                }
              }
              self.addTweets(tweets);
              return tweets.length;
            });
          },
          getTweetsChunked: function (chunkFn, q) {
            var self = this;
            chunkFn = chunkFn || function (tweets) { return tweets.length; };
            q = q || {};
            self.getTweets(q, function () {
              if (!chunkFn.apply(self, arguments)) return;
              self.getTweetsChunked(chunkFn, $.extend(null, q, {
                skip: (q.skip || 0) + self.TWEET_CHUNK_SIZE
              }));
            });
          },
          getTweets: function (q, fn) {
            var self = this;
            return io.socket.get('/tweet', $.extend({
              retweeted: false,
              geo_status: 'resolved',
              timestamp: {'>': self.getPruneAgeAgo()},
              sort: 'timestamp DESC',
              limit: self.TWEET_CHUNK_SIZE
            }, q), fn);
          },
          addTweets: function (tweets) {
            var tweetsAdded = tweets.length;
            console.log('addTweets', tweetsAdded);
            var self = this;
            var now = moment();
            var markers = [];
            var heatMarkers = [];
            $.each(tweets, function (_, tweet) {
              if (!tweet.geojson) return;
              var timeAgo = now.diff(tweet.timestamp);
              if (timeAgo > self.TWEET_PRUNE_AGE) return;

              popupView.$data = tweet;
              var popupHTML = popupView.$el.innerHTML;
              tweet.marker = L.marker(tweet.geojson.coordinates, {title: $('<div>').html(popupHTML).text()})
                .bindPopup(popupHTML);
              markers.push(tweet.marker);

              tweet.heatMarker = $.map(tweet.geojson.coordinates, Number)
                .concat([10 * (self.TWEET_PRUNE_AGE - timeAgo) / self.TWEET_PRUNE_AGE]);
              heatMarkers.push(tweet.heatMarker);
            });
            self.markerCluster.addLayers(markers);
            tweets = tweets.concat(self.tweets);
            self.tweets = ms.merge(tweets, tweetCmp, 0, tweetsAdded, tweets.length);
            self.markerCluster.removeLayers($.map(self.pruneTweets(), function (tweet) {
              return tweet.marker;
            }));
            self.heatLayer.setLatLngs(heatMarkers
              .concat(self.heatLayer._latlngs)
              .slice(0, self.tweets.length));
          },
          pruneTweets: function (tweets) {
            var self = this;
            tweets = tweets || self.tweets;
            return tweets.splice(insertionIndex(bs(tweets, {timestamp: self.getPruneAgeAgo()}, tweetKey)), Infinity);
          },
          getPruneAgeAgo: function () { return moment().subtract(this.TWEET_PRUNE_AGE).toDate(); }
        }
      });
    });
  });
}(this));
</script>
